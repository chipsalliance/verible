// Copyright 2017-2020 The Verible Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Unit tests for VerilogLexer (from verilog.lex)
#include "verilog/parser/verilog_lexer.h"

#include <initializer_list>
#include <utility>

#include "gtest/gtest.h"
#include "absl/strings/string_view.h"
#include "common/lexer/lexer_test_util.h"
#include "common/text/token_info.h"
#include "verilog/parser/verilog_token_enum.h"

namespace verilog {
namespace {

// Removes non-essential tokens from token output stream, such as spaces.
class FilteredVerilogLexer : public VerilogLexer {
 public:
  explicit FilteredVerilogLexer(absl::string_view code) : VerilogLexer(code) {}

  const verible::TokenInfo& DoNextToken() override {
    do {
      VerilogLexer::DoNextToken();
    } while (!VerilogLexer::KeepSyntaxTreeTokens(GetLastToken()));
    return GetLastToken();
  }
};

// Some tests work on filtered tokens, others check unfiltered tokens.
using verible::GenericTestData;
// TODO(b/139743437): Upgrade GenericTestDataSequence to LexerTestData.
using verible::GenericTestDataSequence;
using verible::SimpleTestData;
using LexerTestData = verible::SynthesizedLexerTestData;

// Forwarding function to the template test driver function.
template <typename... Args>
static void TestLexer(Args&&... args) {
  verible::TestLexer<VerilogLexer>(std::forward<Args>(args)...);
}

// Forwarding function to the template test driver function.
template <typename... Args>
static void TestFilteredLexer(Args&&... args) {
  verible::TestLexer<FilteredVerilogLexer>(std::forward<Args>(args)...);
}

static std::initializer_list<LexerTestData> kCommentTests = {
    {{TK_COMMENT_BLOCK, "/**/"}},
    {{TK_COMMENT_BLOCK, "/***/"}},
    {{TK_COMMENT_BLOCK, "/*  */"}},
    {{TK_COMMENT_BLOCK, "/* foo */"}},
    {{TK_COMMENT_BLOCK, "/* foo\nbar */"}},
    {{TK_EOL_COMMENT, "//"}, {TK_NEWLINE, "\n"}},
    {{TK_EOL_COMMENT, "//"}, {TK_NEWLINE, "\r"}},
    {{TK_EOL_COMMENT, "// foo"}, {TK_NEWLINE, "\n"}},
    {{TK_EOL_COMMENT, "// bar"}, {TK_NEWLINE, "\r"}},
    {{TK_EOL_COMMENT, "//foo"}, {TK_NEWLINE, "\n"}},
    // {"// foo"},  // fails b/c expecting endline
};

// treating attributes lists as C-style comments,
// except they are not returned as comment blocks.
static std::initializer_list<SimpleTestData> kAttributeTests = {
    {"(**)"},        {"(*     *)"},
    {"(* x)*)"},     {"(* **  *)"},
    {"(***)"},       {"(** **)"},
    {"(*\n*)"},      {"(* style=flat *)"},
    {"(*foo=bar*)"}, {"(* style=flat, fill=empty *)"},
};

static std::initializer_list<LexerTestData> kAttributeSequenceTests = {
    {{TK_ATTRIBUTE, "(**)"}, {TK_ATTRIBUTE, "(**)"}},
    {{TK_ATTRIBUTE, "(* style=flat,\nfill=empty *)"}, {TK_NEWLINE, "\n"}},
    {{TK_ATTRIBUTE, "(*garbage\nGARBAGE*)"}, {TK_NEWLINE, "\n"}},
    {{TK_ATTRIBUTE, "(*\ntoken\nsoup\n*)"}, {TK_NEWLINE, "\n"}},
};

static std::initializer_list<LexerTestData> kMacroCallTests = {
    {{MacroCallId, "`FOO"}, '(', ')'},
    {{MacroCallId, "`FOO1"}, '(', ')', ';'},
    {{MacroCallId, "`FOO2"}, '(', ')'},
    {{MacroCallId, "`FOO3"}, '(', {MacroCallCloseToEndLine, ")"}, "\n"},
    {{MacroCallId, "`FOO4"}, '(', {MacroCallCloseToEndLine, ")"}, "\n", ';'},
    {{MacroCallId, "`FOO5"}, '(', {MacroCallCloseToEndLine, ")"}, "  ", "\n"},
    {{MacroCallId, "`FOO5b"}, '(', {MacroCallCloseToEndLine, ")"}, "  \n"},
    {{MacroCallId, "`FOO6"}, '(', ')', ';'},
    {{MacroCallId, "`FOO7"},
     '(',
     {MacroArg, "BAR"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO8"}, '(', {MacroArg, "BAR"}, ')'},
    {{MacroCallId, "`FOO9"},
     {TK_SPACE, "  "},
     '(',
     {MacroArg, "BAR"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO10"}, "  ", '(', {MacroArg, "BAR"}, ')'},
    {{MacroCallId, "`FOO11"},
     "  ",
     '(',
     {MacroArg, "\"bar\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO12"},
     '(',
     {MacroArg, "BAR"},
     ',',
     {MacroArg, "\"bar\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO13"},
     " ",
     '(',
     {MacroArg, "`BAR"},
     ',',
     {MacroArg, "\"bar\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO14"},
     " ",
     '(',
     {MacroArg, "`BAR"},
     ',',
     " ",
     {MacroArg, "\"bar\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO15"},
     '(',
     {MacroArg, "`BAR"},
     ',',
     " ",
     {MacroArg, "\"bar\""},
     ')'},
    // macro arg string literals containing balance characters:
    {{MacroCallId, "`FOO16"},
     '(',
     {MacroArg, "`BAR"},
     ',',
     " ",
     {MacroArg, "\"bar([{\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    // macro arg string literals containing balance characters:
    {{MacroCallId, "`FOO17"},
     '(',
     {MacroArg, "`BAR"},
     ',',
     " ",
     {MacroArg, "\"bar)]}\""},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO18"},
     '(',
     {MacroArg, "{1,2,3}"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO19"},
     '(',
     {MacroArg, "BAR()"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO20"},
     '(',
     {MacroArg, "`BAR()"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO21"}, '(', {MacroArg, "`BAR()"}, ')'},
    {{MacroCallId, "`FOO22"},
     '(',
     {MacroArg, "{1,2,3}"},
     ',',
     {TK_SPACE, " "},
     {MacroArg, "`BAR()"},  // macro arg without trailing spaces
     {TK_SPACE, " "},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO22b"},
     '(',
     {MacroArg, "bar"},
     {TK_SPACE, " "},
     ',',
     {MacroArg, "none"},
     {TK_SPACE, " "},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO23"}, " ", '(', {MacroArg, "{{{}}((){})}"}, ')'},
    {{MacroCallId, "`FOO24"}, '(', {MacroArg, "{{{}}((){})}"}, ')'},
    {{MacroCallId, "`FOO25"},
     '(',
     {MacroArg, "{{{}}((){})}"},
     {MacroCallCloseToEndLine, ")"},
     "\n"},
    {{MacroCallId, "`FOO26"}, " ", '(', {TK_SPACE, "  "}, ')'},
    {{MacroCallId, "`FOO27"}, '(', {TK_NEWLINE, "\n"}, ')'},
    {{MacroCallId, "`FOO28"}, " ", '(', {TK_SPACE, "\t"}, ')'},
    {{MacroCallId, "`FOO29"}, '(', {TK_SPACE, " "}, ',', {TK_SPACE, " "}, ')'},
    {{MacroCallId, "`FOO30"}, '(', ',', ')'},
    {{MacroCallId, "`FOO30b"}, '(', ',', {TK_SPACE, "   "}, ')'},
    {{MacroCallId, "`FOO31"}, '(', ',', ',', ',', ')'},
    {{MacroCallId, "`FOO32"},
     '(',
     " ",
     ',',
     "\n",
     ',',
     "\n\n",
     ',',
     "   ",
     ')'},
    {{MacroCallId, "`FOO33"},
     '(',
     "  ",
     {MacroArg, "abc"},
     "  ",  // trailing spaces separated from preceding macro argument
     ',',
     " ",
     ')'},
    {{MacroCallId, "`FOO34"},
     '(',
     "  ",
     ',',
     "  ",
     {MacroArg, "def"},
     "  ",
     ')'},
    {{MacroCallId, "`FOO35"},
     '(',
     "  ",
     ',',
     "  ",
     {MacroArg, "def"},
     "  ",
     ',',
     " ",
     ')'},
    {{MacroCallId, "`FOO36"}, '(', ',', {MacroArg, "def"}, ',', ')'},
    {{MacroIdItem, "`uvm_func_new"}, {TK_NEWLINE, "\n"}},
    {{MacroIdentifier, "`uvm_func_new"}, ';', {TK_NEWLINE, "\n"}},
    {{MacroIdItem, "`uvm_func_new"}, {TK_SPACE, "      "}, "\n"},
    {{MacroIdItem, "`uvm_func_new"},
     "   ",
     {TK_EOL_COMMENT, "// comment"},
     "\n"},
    {{MacroIdItem, "`uvm_func_new"},
     "   ",
     {TK_COMMENT_BLOCK, "/* comment */"},
     "\n"},
    {{MacroIdItem, "`uvm_func_new"},
     "   ",
     {TK_COMMENT_BLOCK, "/* comment */"},
     "  \n"},
    {{MacroIdItem, "`uvm_func_new"},
     {TK_COMMENT_BLOCK, "/*C*/"},
     {TK_COMMENT_BLOCK, "/*D*/"},
     "  ",
     {TK_EOL_COMMENT, "//E"},
     "\n"},
    {{MacroIdItem, "`uvm_object_utils_end"}, {TK_NEWLINE, "\n"}},
    {{MacroIdItem, "`uvm_func_new"},
     {TK_NEWLINE, "\n"},
     {MacroIdItem, "`uvm_func_tew"},
     {TK_NEWLINE, "\n"}},
    {{MacroIdentifier, "`uvm_blah"},
     ';',
     " ",
     {MacroIdItem, "`uvm_blah"},
     "\n"},
    {{MacroIdentifier, "`macro"},
     " ",
     '+',
     " ",
     {MacroIdentifier, "`schmacro"},
     ';'},
    {{MacroIdentifier, "`macro"}, '+', {MacroIdentifier, "`schmacro"}, ';'},
    {{SymbolIdentifier, "lvalue"},
     " ",
     '=',
     " ",
     {MacroIdItem, "`schmacro"},
     "\n"},
    {{SymbolIdentifier, "lvalue"}, '=', {MacroIdItem, "`schmacro"}, "\n"},

    // with escaped identifiers in call args
    {{MacroCallId, "`FOO"}, '(', {MacroArg, "\\BAR"}, " ", ')'},
    {{MacroCallId, "`FOO"}, '(', {MacroArg, "\\BAR"}, "\t", ')'},
    {{MacroCallId, "`FOO"}, '(', {MacroArg, "\\BAR"}, "\n", ')'},

    // Comments are lexed together with macro arguments
    {{MacroCallId, "`FOO"}, '(', "\n",
     {MacroArg, "/*comment*/ bar"}, "\n",
     ')'},
    {{MacroCallId, "`FOO"}, '(', "\n",
     {MacroArg, "bar /*comment*/"}, "\n",
     ')'},
    {{MacroCallId, "`FOO"}, '(', "\n",
     {MacroArg, "/*\nmulti\nline\n*/ bar"}, "\n",
     ')'},
    {{MacroCallId, "`FOO"}, '(', "\n",
     {MacroArg, "//comment\n bar"}, "\n",
     ')'},
    {{MacroCallId, "`FOO"}, '(', "\n",
     {MacroArg, "//multi\n//line\n//comment\n bar"}, "\n",
     ')'},
};

static std::initializer_list<LexerTestData> kUnfilteredMacroCallTests = {
    {
        {MacroIdItem, "`uvm_func_new"},
        {TK_SPACE, "   "},
        {TK_EOL_COMMENT, "// comment"},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroIdItem, "`uvm_func_new"},
        {TK_SPACE, "   "},
        {TK_COMMENT_BLOCK, "/* comment */"},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroIdItem, "`uvm_func_new"},
        {TK_SPACE, "   "},
        {TK_COMMENT_BLOCK, "/* comment */"},
        {TK_SPACE, "  "},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroIdItem, "`uvm_func_new"},
        {TK_COMMENT_BLOCK, "/*C*/"},
        {TK_COMMENT_BLOCK, "/*D*/"},
        {TK_SPACE, "  "},
        {TK_EOL_COMMENT, "//E"},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroCallId, "`FOO1"},
        '(',
        {TK_SPACE, "  "},
        {MacroCallCloseToEndLine, ")"},
        {TK_SPACE, "  "},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroCallId, "`FOO2"},
        '(',
        {TK_SPACE, "  "},
        {MacroCallCloseToEndLine, ")"},
        {TK_SPACE, "  "},
        {TK_COMMENT_BLOCK, "/* comment */"},
        {TK_SPACE, " "},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroCallId, "`FOO3"},
        '(',
        {MacroCallCloseToEndLine, ")"},
        {TK_SPACE, "  "},
        {TK_EOL_COMMENT, "// comment"},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroCallId, "`FOO4"},
        '(',
        {MacroCallCloseToEndLine, ")"},
        {TK_SPACE, " "},
        {TK_COMMENT_BLOCK, "/* comment */"},
        {TK_SPACE, " "},
        {TK_EOL_COMMENT, "// comment"},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroCallId, "`FOO5"},
        '(',
        {MacroCallCloseToEndLine, ")"},
        {TK_SPACE, " "},
        {TK_COMMENT_BLOCK, "/* comment */"},
        {TK_SPACE, " "},
        {TK_COMMENT_BLOCK, "/* comment */"},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroCallId, "`FOO6"},
        '(',
        {MacroArg, "a"},
        {MacroCallCloseToEndLine, ")"},
        {TK_SPACE, " "},
        {TK_EOL_COMMENT, "// comment"},
        {TK_NEWLINE, "\n"},
    },
    {
        {MacroCallId, "`FOO7"},
        '(',
        {MacroArg, "a"},
        ',',
        {MacroArg, "b"},
        {MacroCallCloseToEndLine, ")"},
        {TK_SPACE, " "},
        {TK_EOL_COMMENT, "// comment"},
        {TK_NEWLINE, "\n"},
    },
};

static std::initializer_list<LexerTestData> kMacroDefineTests = {
    {{PP_define, "`define"},
     {TK_SPACE, " "},
     {PP_Identifier, "FOO"},
     {PP_define_body, ""},
     {TK_NEWLINE, "\n"}},
    {{PP_define, "`define"},
     {TK_SPACE, "    "},
     {PP_Identifier, "FOO"},
     {PP_define_body, ""},
     {TK_NEWLINE, "\n"}},
    {{PP_define, "`define"},
     {TK_SPACE, "    "},
     {PP_Identifier, "FOO"},
     "   ",
     {PP_define_body, ""},
     {TK_NEWLINE, "\n"}},
    {{PP_define, "`define"},
     {TK_SPACE, "\t"},
     {PP_Identifier, "FOO"},
     {PP_define_body, ""},
     "\n"},
    {{PP_define, "`define"},
     {TK_SPACE, "\t\t"},
     {PP_Identifier, "FOO"},
     '(',
     ')',
     " ",
     {PP_define_body, "foo()"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     "  ",
     {PP_define_body, "12"},
     "\n"},
    {{PP_define, "`define"},
     "\t",
     {PP_Identifier, "FOO"},
     "\t",
     {PP_define_body, "13"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     " ",
     {PP_define_body, "\\\n14"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     {PP_define_body, "\\\n"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     {PP_define_body, "\\\n15"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     ')',
     "  ",
     {PP_define_body, "bar()"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ')',
     "  ",
     {PP_define_body, "bar(x);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     " ",
     {PP_define_body, "\"hello\\world\""},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ')',
     " ",
     {PP_define_body, "\"hello\\world\""},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "y"},
     ')',
     " ",
     {PP_define_body, "\"hello\\world\"\\\n\"goodbye.\""},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ',',
     " ",
     {PP_Identifier, "y"},
     ')',
     "  ",
     {PP_define_body, "$bar(x, y);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ',',
     " ",
     {PP_Identifier, "y"},
     ')',
     "   ",
     {PP_define_body, "\\\n$bar(x, y);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     ',',
     " ",
     {PP_Identifier, "y"},
     ',',
     " ",
     {PP_Identifier, "z"},
     ')',
     "   ",
     {PP_define_body, "\\\n$bar(x, y);\\\nzoo();"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "y"},
     ',',
     " ",
     {PP_Identifier, "z"},
     ')',
     "   ",
     {PP_define_body, "\\\nalways look on\\\n\tthe bright side of life"},
     "\n"},
    // 2 definitions:
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     "  ",
     {PP_define_body, "12"},
     "\n",
     {PP_define, "`define"},
     " ",
     {PP_Identifier, "ZOO"},
     '(',
     {PP_Identifier, "a"},
     ',',
     " ",
     {PP_Identifier, "b"},
     ')',
     "  ",
     {PP_define_body, "b - a"},
     "\n"},
    // definition with condition definitions inside body:
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "F"},
     '(',
     {PP_Identifier, "z"},
     ')',
     {PP_define_body,
      "\\\n"
      "`ifdef Z \\\n"
      "`define X z\\\n"
      "`else \\\n"
      "`define X 2 \\\n"
      "`endif"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "GOOD"},
     " ",
     {PP_define_body, "EVIL"},
     "\n",
     {TK_static, "static"},
     " ",
     {TK_void, "void"},
     " ",
     {SymbolIdentifier, "tokens"},
     "\n"},
    // macro parameters with defaults:
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     '=',
     {PP_default_text, "88"},
     ',',
     " ",
     {PP_Identifier, "y"},
     '=',
     {PP_default_text, "\"abc\""},
     ')',
     " ",
     {PP_define_body, "\\\n$bar(y, x);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     '=',
     {PP_default_text, "\"88\""},
     ',',
     " ",
     {PP_Identifier, "y"},
     '=',
     {PP_default_text, "abc"},
     ')',
     " ",
     {PP_define_body, "\\\n$bar(y, x);"},
     "\n"},
    // macro parameters with defaults, padded with spaces
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     " ",
     '=',
     {TK_SPACE, " "},  // leading space
     {PP_default_text, "88"},
     {TK_SPACE, " "},  // trailing space
     ',',
     " ",
     {PP_Identifier, "y"},
     " ",
     '=',
     {TK_SPACE, " "},  // leading space
     {PP_default_text, "\"abc\""},
     {TK_SPACE, " "},  // trailing space
     ')',
     " ",
     {PP_define_body, "\\\n$bar(y, x);"},
     "\n"},
    // testing parenthesis balancing in PP_default_text
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     '=',
     {PP_default_text, "(a,(b,c))"},
     ',',
     " ",
     {PP_Identifier, "y"},
     " ",
     '=',
     " ",  // leading space
     {PP_default_text, "\"non)},{(sense\""},
     " ",  // trailing space
     ')',
     " ",
     {PP_define_body, "\\\nbar(y, x);"},
     "\n"},
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "FOO"},
     '(',
     {PP_Identifier, "x"},
     '=',
     {PP_default_text, "\"\""},
     ',',
     " ",
     {PP_Identifier, "y"},
     " ",
     '=',
     {PP_default_text, "(a,\"bc\")"},
     ')',
     " ",
     {PP_define_body, "\\\nbar(y, x);"},
     "\n"},
    // no line following continuation:
    {{PP_define, "`define"},
     " ",
     {PP_Identifier, "UNFINISHED"},
     " ",
     {PP_define_body, "blah + \\"},
     "\n"},
    // multiple blank newlines after empty definition body
    {{PP_define, "`define"},
     "    ",
     {PP_Identifier, "BAR"},
     {PP_define_body, ""},
     "\n\n\n"},
    // conditional define
    {{PP_ifndef, "`ifndef"},
     "  ",
     {PP_Identifier, "FOO"},
     "\n",
     {PP_define, "`define"},
     "    ",
     {PP_Identifier, "BAR"},
     {PP_define_body, ""},
     "\n\n",
     {PP_endif, "`endif"},
     "\n"},
};

static std::initializer_list<GenericTestDataSequence> kProtectedTests = {
    // TODO(b/134180314): lexer current drops tokens from protected sections,
    // but instead emit the tokens and filter them out.
    {"module foo;\n"
     "`protected\n"
     "`endprotected\n"
     "endmodule\n",
     {TK_module, TK_SPACE, SymbolIdentifier, ';', TK_NEWLINE, TK_NEWLINE,
      TK_endmodule, TK_NEWLINE}},
    {"abc\n"
     "`protected\n"
     "(*&^%$#@!!@#$%^&*(a8sayasd\n"
     "87y&*H*HYgyGYh@#BH)72361^&*\n"
     "`endprotected\n"
     "begin\n",
     {SymbolIdentifier, TK_NEWLINE, TK_NEWLINE, TK_begin, TK_NEWLINE}},
    {"task bar;\n"
     "// pragma protect begin_protected\n"
     "// pragma protect end_protected\n"
     "endtask\n",
     {TK_task, TK_SPACE, SymbolIdentifier, ';', TK_NEWLINE, TK_NEWLINE,
      TK_endtask, TK_NEWLINE}},
    {"end\n"
     "//pragma protect begin_protected\n"
     "(*&^%$#@!!@#$%^&*(a8sayasd\n"
     "87y&*H*HYgyGYh@#BH)72361^&*\n"
     "//pragma protect end_protected\n"
     "always\n",
     {TK_end, TK_NEWLINE, TK_NEWLINE, TK_always, TK_NEWLINE}},
    {"end\n"
     "`pragma protect begin_protected\n"
     "(*&^%$#@!!@#$%^&*(a8sayasd\n"
     "87y&*H*HYgyGYh@#BH)72361^&*\n"
     "`pragma protect end_protected\n"
     "begin\n",
     {TK_end, TK_NEWLINE, TK_NEWLINE, TK_begin, TK_NEWLINE}},
};

static std::initializer_list<SimpleTestData> kSymbolIdentifierTests = {
    {"a"},    {" a"},   {"\t\ta"},   {"\nb"},     {"_"},   {"_987"},
    {"_1u"},  {"_$"},   {"_$_"},     {"Foo"},     {"F00"}, {"Foo222"},
    {"_Foo"}, {"Foo$"}, {"Foo_Bar"}, {"Foo$Bar"},
};

static std::initializer_list<SimpleTestData> kEscapedIdentifierTests = {
    // escaped identifiers
    {"\\foo "},
    {"\\__ "},
    {"\\555 "},
    {"\\these.are[really]ugly "},
    {"\\5.6.7.8 "},
    {"\\)(*&^%$#@! "},
    {"\\]fdg[];'[as321=-+/.,>. "},
    {"\\..:;;{]{*&!6^$94* "},
};

static std::initializer_list<SimpleTestData> kMacroIdentifierTests = {
    // treat `identifier (macro-constants) like plain identifier
    {"`foo"},
    {"`foo789"},
    {"`___"},
    {"`_oo00OO"},
};

static std::initializer_list<LexerTestData> kKeywordTests = {
    {{TK_1step, "1step"}},
    {{TK_always, "always"}},
    {{TK_and, "and"}},
    {{TK_assign, "assign"}},
    {{TK_begin, "begin"}},
    {{TK_buf, "buf"}},
    {{TK_bufif0, "bufif0"}},
    {{TK_bufif1, "bufif1"}},
    {{TK_case, "case"}},
    {{TK_casex, "casex"}},
    {{TK_casez, "casez"}},
    {{TK_cmos, "cmos"}},
    {{TK_deassign, "deassign"}},
    {{TK_default, "default"}},
    {{TK_defparam, "defparam"}},
    {{TK_disable, "disable"}},
    {{TK_edge, "edge"}},
    {{TK_else, "else"}},
    {{TK_end, "end"}},
    {{TK_endcase, "endcase"}},
    {{TK_endfunction, "endfunction"}},
    {{TK_endmodule, "endmodule"}},
    {{TK_endprimitive, "endprimitive"}},
    {{TK_endspecify, "endspecify"}},
    {{SymbolIdentifier, "endtable"}},  // is keyword in table context
    {{TK_endtask, "endtask"}},
    {{TK_event, "event"}},
    {{SymbolIdentifier, "find"}},
    {{SymbolIdentifier, "find_index"}},
    {{SymbolIdentifier, "find_first"}},
    {{SymbolIdentifier, "find_first_index"}},
    {{SymbolIdentifier, "find_last"}},
    {{SymbolIdentifier, "find_last_index"}},
    {{TK_for, "for"}},
    {{TK_force, "force"}},
    {{TK_forever, "forever"}},
    {{TK_fork, "fork"}},
    {{TK_function, "function"}},
    {{TK_highz0, "highz0"}},
    {{TK_highz1, "highz1"}},
    {{TK_if, "if"}},
    {{TK_ifnone, "ifnone"}},
    {{TK_initial, "initial"}},
    {{TK_inout, "inout"}},
    {{TK_input, "input"}},
    {{TK_integer, "integer"}},
    {{TK_join, "join"}},
    {{TK_large, "large"}},
    {{TK_macromodule, "macromodule"}},
    {{TK_medium, "medium"}},
    {{TK_module, "module"}},
    {{TK_nand, "nand"}},
    {{TK_negedge, "negedge"}},
    {{TK_nmos, "nmos"}},
    {{TK_nor, "nor"}},
    {{TK_not, "not"}},
    {{TK_notif0, "notif0"}},
    {{TK_notif1, "notif1"}},
    {{TK_or, "or"}},
    {{TK_output, "output"}},
    {{TK_parameter, "parameter"}},
    {{TK_pmos, "pmos"}},
    {{TK_posedge, "posedge"}},
    {{TK_primitive, "primitive"}},
    {{TK_pull0, "pull0"}},
    {{TK_pull1, "pull1"}},
    {{TK_pulldown, "pulldown"}},
    {{TK_pullup, "pullup"}},
    {{TK_rcmos, "rcmos"}},
    {{TK_real, "real"}},
    {{TK_realtime, "realtime"}},
    {{TK_reg, "reg"}},
    {{TK_release, "release"}},
    {{TK_repeat, "repeat"}},
    {{TK_rnmos, "rnmos"}},
    {{TK_rpmos, "rpmos"}},
    {{TK_rtran, "rtran"}},
    {{TK_rtranif0, "rtranif0"}},
    {{TK_rtranif1, "rtranif1"}},
    {{TK_scalared, "scalared"}},
    {{TK_small, "small"}},
    {{TK_specify, "specify"}},
    {{TK_specparam, "specparam"}},
    {{TK_strong0, "strong0"}},
    {{TK_strong1, "strong1"}},
    {{TK_supply0, "supply0"}},
    {{TK_supply1, "supply1"}},
    {{SymbolIdentifier, "table"}},  // is keyword inside primitive context
    {{TK_task, "task"}},
    {{TK_time, "time"}},
    {{TK_tran, "tran"}},
    {{TK_tranif0, "tranif0"}},
    {{TK_tranif1, "tranif1"}},
    {{TK_tri, "tri"}},
    {{TK_tri0, "tri0"}},
    {{TK_tri1, "tri1"}},
    {{TK_triand, "triand"}},
    {{TK_trior, "trior"}},
    {{TK_trireg, "trireg"}},
    {{TK_vectored, "vectored"}},
    {{TK_wait, "wait"}},
    {{TK_wand, "wand"}},
    {{TK_weak0, "weak0"}},
    {{TK_weak1, "weak1"}},
    {{TK_while, "while"}},
    {{TK_wire, "wire"}},
    {{TK_wor, "wor"}},
    {{TK_xnor, "xnor"}},
    {{TK_xor, "xor"}},
    {{TK_Shold, "$hold"}},
    {{TK_Snochange, "$nochange"}},
    {{TK_Speriod, "$period"}},
    {{TK_Srecovery, "$recovery"}},
    {{TK_Ssetup, "$setup"}},
    {{TK_Ssetuphold, "$setuphold"}},
    {{TK_Sskew, "$skew"}},
    {{TK_Swidth, "$width"}},
    {{TKK_attribute, "$attribute"}},
    {{TK_bool, "bool"}},
    {{TK_automatic, "automatic"}},
    {{TK_endgenerate, "endgenerate"}},
    {{TK_generate, "generate"}},
    {{TK_genvar, "genvar"}},
    {{TK_localparam, "localparam"}},
    {{TK_noshowcancelled, "noshowcancelled"}},
    {{TK_pulsestyle_onevent, "pulsestyle_onevent"}},
    {{TK_pulsestyle_ondetect, "pulsestyle_ondetect"}},
    {{TK_showcancelled, "showcancelled"}},
    {{TK_signed, "signed"}},
    {{TK_unsigned, "unsigned"}},
    {{TK_Sfullskew, "$fullskew"}},
    {{TK_Srecrem, "$recrem"}},
    {{TK_Sremoval, "$removal"}},
    {{TK_Stimeskew, "$timeskew"}},
    {{TK_cell, "cell"}},
    {{TK_config, "config"}},
    {{TK_design, "design"}},
    {{TK_endconfig, "endconfig"}},
    {{TK_incdir, "incdir"}},
    {{TK_include, "include"}},
    {{TK_instance, "instance"}},
    {{TK_liblist, "liblist"}},
    {{TK_library, "library"}},
    {{TK_use, "use"}},
    {{TK_wone, "wone"}},
    {{TK_uwire, "uwire"}},
    {{TK_alias, "alias"}},
    {{TK_always_comb, "always_comb"}},
    {{TK_always_ff, "always_ff"}},
    {{TK_always_latch, "always_latch"}},
    {{TK_assert, "assert"}},
    {{TK_assume, "assume"}},
    {{TK_before, "before"}},
    {{TK_bind, "bind"}},
    {{TK_bins, "bins"}},
    {{TK_binsof, "binsof"}},
    {{TK_bit, "bit"}},
    {{TK_break, "break"}},
    {{TK_byte, "byte"}},
    {{TK_chandle, "chandle"}},
    {{TK_class, "class"}},
    {{TK_clocking, "clocking"}},
    {{TK_const, "const"}},
    {{TK_constraint, "constraint"}},
    {{TK_context, "context"}},
    {{TK_continue, "continue"}},
    {{TK_cover, "cover"}},
    {{TK_covergroup, "covergroup"}},
    {{TK_coverpoint, "coverpoint"}},
    {{TK_cross, "cross"}},
    {{TK_dist, "dist"}},
    {{TK_do, "do"}},
    {{TK_endclass, "endclass"}},
    {{TK_endclocking, "endclocking"}},
    {{TK_endgroup, "endgroup"}},
    {{TK_endinterface, "endinterface"}},
    {{TK_endpackage, "endpackage"}},
    {{TK_endprogram, "endprogram"}},
    {{TK_endproperty, "endproperty"}},
    {{TK_endsequence, "endsequence"}},
    {{TK_enum, "enum"}},
    {{TK_expect, "expect"}},
    {{TK_export, "export"}},
    {{TK_extends, "extends"}},
    {{TK_extern, "extern"}},
    {{TK_final, "final"}},
    {{TK_first_match, "first_match"}},
    {{TK_foreach, "foreach"}},
    {{TK_forkjoin, "forkjoin"}},
    {{TK_iff, "iff"}},
    {{TK_ignore_bins, "ignore_bins"}},
    {{TK_illegal_bins, "illegal_bins"}},
    {{TK_import, "import"}},
    {{TK_inside, "inside"}},
    {{TK_int, "int"}},
    {{TK_interface, "interface"}},
    {{TK_intersect, "intersect"}},
    {{TK_join_any, "join_any"}},
    {{TK_join_none, "join_none"}},
    {{TK_local_SCOPE, "local::"}},
    {{TK_local, "local"}},
    {{TK_logic, "logic"}},
    {{TK_longint, "longint"}},
    {{TK_matches, "matches"}},
    {{TK_modport, "modport"}},
    {{TK_new, "new"}},
    {{TK_null, "null"}},
    {{TK_package, "package"}},
    {{TK_packed, "packed"}},
    {{TK_priority, "priority"}},
    {{TK_program, "program"}},
    {{TK_property, "property"}},
    {{TK_protected, "protected"}},
    {{TK_pure, "pure"}},
    {{TK_rand, "rand"}},
    {{TK_randc, "randc"}},
    {{TK_randcase, "randcase"}},
    {{TK_randsequence, "randsequence"}},
    {{TK_randomize, "randomize"}},
    {{TK_randomize, "std::randomize"}},
    {{TK_ref, "ref"}},
    {{TK_return, "return"}},
    {{TK_Sroot, "$root"}},
    {{TK_sequence, "sequence"}},
    {{TK_shortint, "shortint"}},
    {{TK_shortreal, "shortreal"}},
    {{TK_solve, "solve"}},
    {{TK_static, "static"}},
    {{TK_string, "string"}},
    {{TK_struct, "struct"}},
    {{TK_super, "super"}},
    {{TK_tagged, "tagged"}},
    {{TK_this, "this"}},
    {{TK_throughout, "throughout"}},
    {{TK_timeprecision, "timeprecision"}},
    {{TK_timeunit, "timeunit"}},
    {{TK_type, "type"}},
    {{TK_typedef, "typedef"}},
    {{TK_union, "union"}},
    {{TK_unique, "unique"}},
    {{TK_Sunit, "$unit"}},
    {{TK_var, "var"}},
    {{TK_virtual, "virtual"}},
    {{TK_void, "void"}},
    {{TK_wait_order, "wait_order"}},
    {{TK_wildcard, "wildcard"}},
    {{TK_with, "with"}},
    {{TK_within, "within"}},
    {{TK_timeprecision_check, "timeprecision_check"}},
    {{TK_timeunit_check, "timeunit_check"}},
    {{TK_accept_on, "accept_on"}},
    {{TK_checker, "checker"}},
    {{TK_endchecker, "endchecker"}},
    {{TK_eventually, "eventually"}},
    {{TK_global, "global"}},
    {{TK_implies, "implies"}},
    {{TK_let, "let"}},
    {{TK_nexttime, "nexttime"}},
    {{TK_reject_on, "reject_on"}},
    {{TK_restrict, "restrict"}},
    {{TK_s_always, "s_always"}},
    {{TK_s_eventually, "s_eventually"}},
    {{TK_s_nexttime, "s_nexttime"}},
    {{TK_s_until, "s_until"}},
    {{TK_s_until_with, "s_until_with"}},
    {{TK_strong, "strong"}},
    {{TK_sync_accept_on, "sync_accept_on"}},
    {{TK_sync_reject_on, "sync_reject_on"}},
    {{TK_unique0, "unique0"}},
    {{TK_until, "until"}},
    {{TK_until_with, "until_with"}},
    {{TK_untyped, "untyped"}},
    {{TK_weak, "weak"}},
    {{TK_implements, "implements"}},
    {{TK_interconnect, "interconnect"}},
    {{TK_nettype, "nettype"}},
    {{TK_soft, "soft"}},
    {{TK_above, "above"}},
    {{TK_abs, "abs"}},
    {{TK_absdelay, "absdelay"}},
    {{TK_abstol, "abstol"}},
    {{TK_access, "access"}},
    {{TK_acos, "acos"}},
    {{TK_acosh, "acosh"}},
    {{TK_ac_stim, "ac_stim"}},
    {{TK_aliasparam, "aliasparam"}},
    {{TK_analog, "analog"}},
    {{TK_analysis, "analysis"}},
    {{TK_asin, "asin"}},
    {{TK_asinh, "asinh"}},
    {{TK_atan, "atan"}},
    {{TK_atan2, "atan2"}},
    {{TK_atanh, "atanh"}},
    {{TK_branch, "branch"}},
    {{TK_ceil, "ceil"}},
    {{TK_connect, "connect"}},
    {{TK_connectmodule, "connectmodule"}},
    {{TK_connectrules, "connectrules"}},
    {{TK_continuous, "continuous"}},
    {{TK_cos, "cos"}},
    {{TK_cosh, "cosh"}},
    {{TK_ddt, "ddt"}},
    {{TK_ddt_nature, "ddt_nature"}},
    {{TK_ddx, "ddx"}},
    {{TK_discipline, "discipline"}},
    {{TK_discrete, "discrete"}},
    {{SymbolIdentifier, "domain"}},  // is keyword in discipline context
    {{TK_driver_update, "driver_update"}},
    {{TK_endconnectrules, "endconnectrules"}},
    {{TK_enddiscipline, "enddiscipline"}},
    {{TK_endnature, "endnature"}},
    {{TK_endparamset, "endparamset"}},
    {{TK_exclude, "exclude"}},
    {{TK_exp, "exp"}},
    {{TK_final_step, "final_step"}},
    {{TK_flicker_noise, "flicker_noise"}},
    {{TK_floor, "floor"}},
    {{TK_flow, "flow"}},
    {{TK_from, "from"}},
    {{TK_ground, "ground"}},
    {{TK_hypot, "hypot"}},
    {{TK_idt, "idt"}},
    {{TK_idtmod, "idtmod"}},
    {{TK_idt_nature, "idt_nature"}},
    {{TK_inf, "inf"}},
    {{TK_infinite, "infinite"}},
    {{TK_initial_step, "initial_step"}},
    {{TK_laplace_nd, "laplace_nd"}},
    {{TK_laplace_np, "laplace_np"}},
    {{TK_laplace_zd, "laplace_zd"}},
    {{TK_laplace_zp, "laplace_zp"}},
    {{TK_last_crossing, "last_crossing"}},
    {{TK_limexp, "limexp"}},
    {{TK_ln, "ln"}},
    {{TK_log, "log"}},
    {{SymbolIdentifier, "max"}},
    {{TK_merged, "merged"}},
    {{SymbolIdentifier, "min"}},
    {{TK_nature, "nature"}},
    {{TK_net_resolution, "net_resolution"}},
    {{TK_noise_table, "noise_table"}},
    {{TK_paramset, "paramset"}},
    {{TK_potential, "potential"}},
    {{TK_pow, "pow"}},
    {{TK_resolveto, "resolveto"}},
    {{TK_sin, "sin"}},
    {{TK_sinh, "sinh"}},
    {{TK_slew, "slew"}},
    {{TK_split, "split"}},
    {{TK_sqrt, "sqrt"}},
    {{TK_tan, "tan"}},
    {{TK_tanh, "tanh"}},
    {{TK_timer, "timer"}},
    {{TK_transition, "transition"}},
    {{TK_units, "units"}},
    {{TK_white_noise, "white_noise"}},
    {{TK_wreal, "wreal"}},
    {{TK_zi_nd, "zi_nd"}},
    {{TK_zi_np, "zi_np"}},
    {{TK_zi_zd, "zi_zd"}},
    {{TK_zi_zp, "zi_zp"}},
    {{TK_PLUS_EQ, "+="}},
    {{TK_MINUS_EQ, "-="}},
    {{TK_MUL_EQ, "*="}},
    {{TK_DIV_EQ, "/="}},
    {{TK_MOD_EQ, "%="}},
    {{TK_AND_EQ, "&="}},
    {{TK_OR_EQ, "|="}},
    {{TK_XOR_EQ, "^="}},
    {{TK_INCR, "++"}},
    {{TK_DECR, "--"}},
    {{TK_LE, "<="}},
    {{TK_GE, ">="}},
    {{TK_EG, "=>"}},
    {{TK_WILDCARD_EQ, "==?"}},
    {{TK_EQ, "=="}},
    {{TK_WILDCARD_NE, "!=?"}},
    {{TK_NE, "!="}},
    {{TK_CEQ, "==="}},
    {{TK_CNE, "!=="}},
    {{TK_LP, "'{"}},
    {{TK_LS, "<<"}},
    {{TK_RS, ">>"}},
    {{TK_RSS, ">>>"}},
    {{TK_SG, "*>"}},
    {{TK_CONTRIBUTE, "<+"}},
    {{TK_PO_POS, "+:"}},
    {{TK_PO_NEG, "-:"}},
    {{TK_POW, "**"}},
    // {{TK_PSTAR , { "(*"}},  // ignored by lexer, treated as comment
    // {{TK_STARP , { "*)"}},  // ignored by lexer, treated as comment
    {{TK_DOTSTAR, ".*"}},
    {{TK_LOR, "||"}},
    {{TK_LAND, "&&"}},
    {{TK_TAND, "&&&"}},
    {{TK_NAND, "~&"}},
    {{TK_NOR, "~|"}},
    {{TK_NXOR, "~^"}},
    {{_TK_RARROW, "->"}},  // This can disambiguate to different enums,
                           // depending on context.
    {{TK_LOGEQUIV, "<->"}},
    {{TK_SCOPE_RES, "::"}},
    {{TK_COLON_EQ, ":="}},
    {{TK_COLON_DIV, ":/"}},
    {{TK_POUNDPOUND, "##"}},
    {{TK_LBSTAR, "[*"}},
    {{TK_LBSTARRB, "[*]"}},
    {{TK_LBPLUSRB, "[+]"}},
    {{TK_LBEQ, "[="}},
    {{TK_LBRARROW, "[->"}},
};

static std::initializer_list<SimpleTestData> kSingleCharTokenTests = {
    {"}"}, {"{"}, {";"}, {":"}, {"["}, {"]"}, {","}, {"("}, {")"},
    {"#"}, {"="}, {"."}, {"@"}, {"&"}, {"!"}, {"?"}, {"<"}, {">"},
    {"%"}, {"|"}, {"^"}, {"~"}, {"+"}, {"*"}, {"/"}, {"-"}, {"\'"},
};

static std::initializer_list<SimpleTestData> kRealTimeTests = {
    // scientific units
    {"1e-3"},
    {"2e+3"},
    {"3e6"},
    {"4E6"},
    {"5.12e-6"},
    {"0e-0"},
    {"0e+0"},
    {"6e-12"},
    {"7e-100"},
    {"6.02e-23"},
    {"2.9e8"},
    // scaled units are for Verilog-AMS
    {"1u"},
    {"2a"},
    {"3f"},
    {"4m"},
    {"5p"},
    {"6k"},
    {"6K"},
    {"7M"},
    {"8G"},
    {"9T"},
    {"2.5n"},
    {"100p"},
    {"10.0p"},
    {"0.01m"},
    {"0m"},
};

static std::initializer_list<LexerTestData> kBasedNumberTests = {
    {{TK_UnBasedNumber, "'0"}},
    {{TK_UnBasedNumber, "'1"}},
    {{TK_UnBasedNumber, "'x"}},
    {{TK_UnBasedNumber, "'X"}},
    {{TK_UnBasedNumber, "'z"}},
    {{TK_UnBasedNumber, "'Z"}},
    {{TK_DecBase, "'d"}, {TK_DecDigits, "0"}},
    {{TK_DecBase, "'d"}, {TK_SPACE, " "}, {TK_DecDigits, "0"}},
    {{TK_DecBase, "'d"}, {TK_DecDigits, "20"}},
    {{TK_DecBase, "'d"}, {TK_DecDigits, "20__"}},
    {{TK_DecBase, "'sd"}, {TK_DecDigits, "9"}},
    {{TK_DecBase, "'SD"}, {TK_DecDigits, "12"}},
    {{TK_DecBase, "'d"}, {TK_XZDigits, "x"}},
    {{TK_DecBase, "'d"}, {TK_SPACE, " "}, {TK_XZDigits, "x"}},
    {{TK_DecBase, "'d"}, {TK_NEWLINE, "\n"}, {TK_XZDigits, "x"}},
    {{TK_DecBase, "'d"}, {TK_XZDigits, "x_"}},
    {{TK_DecBase, "'d"}, {TK_XZDigits, "Z"}},
    {{TK_DecBase, "'d"}, {TK_XZDigits, "?"}},
    {{TK_BinBase, "'B"}, {TK_BinDigits, "0"}},
    {{TK_BinBase, "'b"}, {TK_BinDigits, "1"}},
    {{TK_BinBase, "'b"}, {TK_SPACE, " "}, {TK_BinDigits, "1"}},
    {{TK_BinBase, "'b"}, {TK_NEWLINE, "\n"}, {TK_BinDigits, "1"}},
    {{TK_BinBase, "'b"}, {TK_BinDigits, "x"}},
    {{TK_BinBase, "'b"}, {TK_BinDigits, "z"}},
    {{TK_BinBase, "'b"}, {TK_BinDigits, "1100"}},
    {{TK_BinBase, "'b"}, {TK_BinDigits, "xX10Zz"}},
    {{TK_BinBase, "'b"}, {TK_BinDigits, "_x_X_10_Zz"}},
    {{TK_OctBase, "'o"}, {TK_OctDigits, "0"}},
    {{TK_OctBase, "'o"}, {TK_OctDigits, "000"}},
    {{TK_OctBase, "'o"}, {TK_OctDigits, "777"}},
    {{TK_OctBase, "'o"}, {TK_SPACE, " "}, {TK_OctDigits, "777"}},
    {{TK_OctBase, "'o"}, {TK_NEWLINE, "\n"}, {TK_OctDigits, "777"}},
    {{TK_OctBase, "'o"}, {TK_OctDigits, "_007_007_"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "0"}},
    {{TK_HexBase, "'h"}, {TK_SPACE, " "}, {TK_HexDigits, "0"}},
    {{TK_HexBase, "'h"}, {TK_NEWLINE, "\n"}, {TK_HexDigits, "0"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "a"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "e110"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "_feed_face"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "0_cafebabe_"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "00d_f00d"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "xXXxcaca"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "cacazzZZ"}},
    {{TK_HexBase, "'h"}, {TK_HexDigits, "e110???_000"}},
};

static std::initializer_list<SimpleTestData> kTimeLiteralTests = {
    {"1fs"},    {"2ps"},    {"3ns"},      {"4us"},    {"5ms"}, {"6.6fs"},
    {"7.77ps"}, {"88.0ns"}, {"999.99us"}, {"10.0ms"}, {"66s"},
    // {"1 ms"}, {"11.0 ms"},  // only allowed in `timescale context
};

static std::initializer_list<SimpleTestData> kStringLiteralTests = {
    {"\"\""},
    {"\".\""},
    {"\"...\""},
    {"\":)\""},
    {"\"^ ^\""},
    {"\"O_o\""},
    {"\"foobar\""},
    {"\"foo bar\""},
    {"\"the\\\\great\\\\escape\""},
    {"\"the\\\"great\\\"escape\""},
    {"\"the\\nGREAT\\nescape\""},  // with line continuations
};

// tokens with special handling in lexer
static std::initializer_list<LexerTestData> kTrickyTests = {
    {{'*', "(*)"}},
    {{TK_COLON_DIV, ":/"}, {TK_SPACE, " "}},
    {{TK_COLON_DIV, ":/"}, {TK_DecNumber, "8"}},
    {':', {TK_EOL_COMMENT, "//"}, {TK_NEWLINE, "\n"}},
    {':', {TK_COMMENT_BLOCK, "/*ignore*/"}, {TK_NEWLINE, "\n"}},
    {{TK_DecNumber, "0"},
     ':',
     {TK_EOL_COMMENT, "// case description"},
     {TK_NEWLINE, "\n"}},
    {{SymbolIdentifier, "FOO"},
     {TK_SPACE, " "},
     {TK_LINE_CONT, "\\"},
     {TK_NEWLINE, "\n"},
     {SymbolIdentifier, "BAR"},
     ';'},
};

// make sure these are lexed as separate tokens
static std::initializer_list<GenericTestDataSequence> kSequenceTests = {
    {"+=>", {'+', TK_EG}},
    {"-=>", {'-', TK_EG}},
    {"###", {TK_POUNDPOUND, '#'}},
    {"####", {TK_POUNDPOUND, TK_POUNDPOUND}},
    {"[-12]", {'[', '-', TK_DecNumber, ']'}},
    {"[*2]", {TK_LBSTAR, TK_DecNumber, ']'}},
    {"[ *3]", {'[', '*', TK_DecNumber, ']'}},
    {"[=1]", {TK_LBEQ, TK_DecNumber, ']'}},
    {"[ =1]", {'[', '=', TK_DecNumber, ']'}},
    {"[->]", {TK_LBRARROW, ']'}},
    {"[ ->]", {'[', _TK_RARROW, ']'}},
    {"`WIDTH'd777", {MacroNumericWidth, TK_DecBase, TK_DecDigits}},
    {"`WIDTH'd`DIGITS", {MacroNumericWidth, TK_DecBase, MacroIdentifier}},
    {"`WIDTH 'h888", {MacroNumericWidth, TK_HexBase, TK_HexDigits}},
    {"`WIDTH 'h `DIGITS", {MacroNumericWidth, TK_HexBase, MacroIdentifier}},
    {"`WIDTH \t 'o654", {MacroNumericWidth, TK_OctBase, TK_OctDigits}},
    {"`WIDTH'b101", {MacroNumericWidth, TK_BinBase, TK_BinDigits}},
    {"`WIDTH'b10zx", {MacroNumericWidth, TK_BinBase, TK_BinDigits}},
    {"`WIDTH'b`DIGITS", {MacroNumericWidth, TK_BinBase, MacroIdentifier}},
    {"(*)(*)", {'*', '*'}},
    {"(*) (*)", {'*', '*'}},
    {"(* ) (*  )", {'*', '*'}},
};

static std::initializer_list<GenericTestDataSequence> kContextKeywordTests = {
    {"option", {SymbolIdentifier}},
    {"covergroup blah option blah endgroup option",
     {TK_covergroup, SymbolIdentifier, TK_option, SymbolIdentifier, TK_endgroup,
      SymbolIdentifier}},
    {"with covergroup with endgroup with",
     {TK_with, TK_covergroup, TK_with__covergroup, TK_endgroup, TK_with}},
    {"domain discipline domain enddiscipline domain",
     {SymbolIdentifier, TK_discipline, TK_domain, TK_enddiscipline,
      SymbolIdentifier}},
};

static std::initializer_list<GenericTestDataSequence>
    kBuiltinMethodKeywordTests = {
        {". randomize()", {'.', TK_randomize, '(', ')'}},
        {".randomize with", {'.', TK_randomize, TK_with}},
        {"min . min min", {SymbolIdentifier, '.', TK_min, SymbolIdentifier}},
        {"min . minime min",
         {SymbolIdentifier, '.', SymbolIdentifier, SymbolIdentifier}},
        {"max.max max", {SymbolIdentifier, '.', TK_max, SymbolIdentifier}},
        {"max.maximum max",
         {SymbolIdentifier, '.', SymbolIdentifier, SymbolIdentifier}},
        {"find . find find",
         {SymbolIdentifier, '.', TK_find, SymbolIdentifier}},
        {".finder", {'.', SymbolIdentifier}},
        {"find_index . find_index find_index",
         {SymbolIdentifier, '.', TK_find_index, SymbolIdentifier}},
        {"find_first . find_first find_first",
         {SymbolIdentifier, '.', TK_find_first, SymbolIdentifier}},
        {"find_first_index.find_first_index find_first",
         {SymbolIdentifier, '.', TK_find_first_index, SymbolIdentifier}},
        {"find_last . find_last find_last",
         {SymbolIdentifier, '.', TK_find_last, SymbolIdentifier}},
        {"find_last_index.find_last_index find_last",
         {SymbolIdentifier, '.', TK_find_last_index, SymbolIdentifier}},
        {"unique . unique unique", {TK_unique, '.', TK_unique, TK_unique}},
        {"uniquely.uniquely uniquely",
         {SymbolIdentifier, '.', SymbolIdentifier, SymbolIdentifier}},
        {"unique_index . unique_index unique_index",
         {SymbolIdentifier, '.', TK_unique_index, SymbolIdentifier}},
        {"sort . sort sort",
         {SymbolIdentifier, '.', TK_sort, SymbolIdentifier}},
        {"rsort .rsort rsort",
         {SymbolIdentifier, '.', TK_rsort, SymbolIdentifier}},
        {"reverse .reverse reverse",
         {SymbolIdentifier, '.', TK_reverse, SymbolIdentifier}},
        {"shuffle .shuffle shuffle",
         {SymbolIdentifier, '.', TK_shuffle, SymbolIdentifier}},
        {"sum . sum sum", {SymbolIdentifier, '.', TK_sum, SymbolIdentifier}},
        {"product .product product",
         {SymbolIdentifier, '.', TK_product, SymbolIdentifier}},
        {"and .and and", {TK_and, '.', TK_and, TK_and}},
        {"or .or or", {TK_or, '.', TK_or, TK_or}},
        {"xor .xor xor", {TK_xor, '.', TK_xor, TK_xor}},
};

static std::initializer_list<GenericTestDataSequence> kEdgeTests = {
    {"edge [] 10", {TK_edge, '[', ']', TK_DecNumber}},
    {"edge\n[] z0", {TK_edge, '[', ']', SymbolIdentifier}},
    {"edge[10]", {TK_edge, '[', TK_edge_descriptor, ']'}},
    {"edge\n[z0]", {TK_edge, '[', TK_edge_descriptor, ']'}},
    {"edge [01 0x 1x x0 z1] 10",
     {TK_edge, '[', TK_edge_descriptor, TK_edge_descriptor, TK_edge_descriptor,
      TK_edge_descriptor, TK_edge_descriptor, ']', TK_DecNumber}},
    {"edge [0x, 10, x1,0z,1z] x0",
     {TK_edge, '[', TK_edge_descriptor, ',', TK_edge_descriptor, ',',
      TK_edge_descriptor, ',', TK_edge_descriptor, ',', TK_edge_descriptor, ']',
      SymbolIdentifier}},
    {"edge x0", {TK_edge, SymbolIdentifier}},
    {"edge x0 [ 10 ]", {TK_edge, SymbolIdentifier, '[', TK_DecNumber, ']'}},
};

static std::initializer_list<GenericTestDataSequence> kUDPTests = {
    {"primitive table endtable endprimitive",
     {TK_primitive, TK_table, TK_endtable, TK_endprimitive}},
    {"primitive table b:l; endtable endprimitive",
     {TK_primitive, TK_table, 'b', ':', 'l', ';', TK_endtable,
      TK_endprimitive}},
    {"primitive table B:L:H; endtable endprimitive",
     {TK_primitive, TK_table, 'b', ':', 'l', ':', 'h', ';', TK_endtable,
      TK_endprimitive}},
    {"primitive table b B l L h H f F r R x X n N p P 0 1 ? * - : ; "
     "endtable B L F H R 1 endprimitive",
     {TK_primitive,
      TK_table,
      'b',
      'b',
      'l',
      'l',
      'h',
      'h',
      'f',
      'f',
      'r',
      'r',
      'x',
      'x',
      'n',
      'n',
      'p',
      'p',
      '0',
      '1',
      '?',
      '*',
      '-',
      ':',
      ';',
      TK_endtable,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      TK_DecNumber,
      TK_endprimitive}},
    {"primitive table (?0) (?1) (?x) (?X) (?"
     "?) (01) (0x) (0X) (bx) (bX) "
     "(b0) (b1) (0?) (10) (1x) (1X) (1?) (x0) (X0) (x1) (X1) (x?) (X?) "
     "endtable b0 bx x1 X0 10 endprimitive",
     {TK_primitive,
      TK_table,
      '_',
      '+',
      '%',
      '%',
      '*',
      'r',
      'Q',
      'Q',
      'q',
      'q',
      'f',
      'r',
      'P',
      'f',
      'M',
      'M',
      'N',
      'F',
      'F',
      'R',
      'R',
      'B',
      'B',
      TK_endtable,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      SymbolIdentifier,
      TK_DecNumber,
      TK_endprimitive}},
    // TK_DecNumber inside UDP should be rejected, and will be caught by parser
    {"primitive table 321", {TK_primitive, TK_table, TK_OTHER}},
    {"primitive table 1010", {TK_primitive, TK_table, '1', '0', '1', '0'}},
    {"primitive table 10\t10", {TK_primitive, TK_table, '1', '0', '1', '0'}},
    {"primitive table 10\n`ifdef BLAH\n10",
     {TK_primitive, TK_table, '1', '0', PP_ifdef, PP_Identifier, '1', '0'}},
};

static std::initializer_list<GenericTestDataSequence> kUnfilteredUDPTests = {
    {"primitive table 10/*comment*/10",
     {TK_primitive, TK_SPACE, TK_table, TK_SPACE, '1', '0', TK_COMMENT_BLOCK,
      '1', '0'}},
};

static std::initializer_list<GenericTestData> kTimingCheckTests = {
    {"$hold", TK_Shold},           {"$nochange", TK_Snochange},
    {"$period", TK_Speriod},       {"$recovery", TK_Srecovery},
    {"$setup", TK_Ssetup},         {"$setuphold", TK_Ssetuphold},
    {"$skew", TK_Sskew},           {"$width", TK_Swidth},
    {"$fullskew", TK_Sfullskew},   {"$recrem", TK_Srecrem},
    {"$removal", TK_Sremoval},     {"$timeskew", TK_Stimeskew},
    {"$attribute", TKK_attribute},
};

static std::initializer_list<GenericTestData> kSystemTaskFunctionTests = {
    {"$display", SystemTFIdentifier},   {"$error", SystemTFIdentifier},
    {"$info", SystemTFIdentifier},      {"$warning", SystemTFIdentifier},
    {"$fatal", SystemTFIdentifier},     {"$finish", SystemTFIdentifier},
    {"$stop", SystemTFIdentifier},      {"$hammertime", SystemTFIdentifier},
    {"$__MAGIC__", SystemTFIdentifier}, {"$thechosen1", SystemTFIdentifier},
};

static std::initializer_list<GenericTestDataSequence> kPreprocessorTests = {
    {"", {}},
    {"`define true false\n", {PP_define, PP_Identifier, PP_define_body}},
    {"  `define SIMULATION\n", {PP_define, PP_Identifier, PP_define_body}},
    {"`elsif\n", {PP_elsif}},
    {"`elsif\nfoo", {PP_elsif, SymbolIdentifier}},
    {"`elsif foo\n", {PP_elsif, PP_Identifier}},
    {"`elsif foo  \n", {PP_elsif, PP_Identifier}},
    {"  `elsif foo  \n", {PP_elsif, PP_Identifier}},
    {"  `elsif foo\n", {PP_elsif, PP_Identifier}},
    {"  `define BAR\n", {PP_define, PP_Identifier, PP_define_body}},
    {"\t\t`define BEAR\n", {PP_define, PP_Identifier, PP_define_body}},
    {"`else\n", {PP_else}},
    {"`else // comment\n", {PP_else}},
    {"`else blah\n", {PP_else, SymbolIdentifier}},
    {"`endif\n", {PP_endif}},
    {"`endif bar\n", {PP_endif, SymbolIdentifier}},
    {"`ifdef evil\n", {PP_ifdef, PP_Identifier}},
    {"     `ifdef     dont_be_evil\n", {PP_ifdef, PP_Identifier}},
    {"     `undef\tdont_be_evil\t\n", {PP_undef, PP_Identifier}},
    {"`ifndef also_evil\n", {PP_ifndef, PP_Identifier}},
    {"`include \"lib/standard_cells.v\"\n", {PP_include, TK_StringLiteral}},
    {"`undef behavior\n", {PP_undef, PP_Identifier}},
    {"`ifdef god_mode\n"
     "`define private public\n"
     "`elsif hacker_mode\n"
     "  `elsif sneaky_mode  \n"
     "  `elsif squeaky_mode\n"
     "`else\n"
     "`endif\n",
     {PP_ifdef, PP_Identifier, PP_define, PP_Identifier, PP_define_body,
      PP_elsif, PP_Identifier, PP_elsif, PP_Identifier, PP_elsif, PP_Identifier,
      PP_else, PP_endif}},
};

static std::initializer_list<GenericTestDataSequence>
    kUnfilteredPreprocessorTests = {
        {"`else // comment\n", {PP_else, TK_SPACE, TK_EOL_COMMENT, TK_NEWLINE}},
};

static std::initializer_list<GenericTestDataSequence>
    kUnfilteredDirectiveTests = {
        {"`timescale 1ps/1ps\n",
         {DR_timescale, TK_SPACE, TK_TimeLiteral, '/', TK_TimeLiteral,
          TK_NEWLINE}},
        {"`pragma fragma\n", {DR_pragma, TK_NEWLINE}},
};

static std::initializer_list<GenericTestDataSequence> kDirectiveTests = {
    {"`timescale", {DR_timescale}},
    {"`timescale 1ps/1ps", {DR_timescale, TK_TimeLiteral, '/', TK_TimeLiteral}},
    {"  `timescale 1ps/1ps",
     {DR_timescale, TK_TimeLiteral, '/', TK_TimeLiteral}},
    {"`timescale 1s / 1ms",
     {DR_timescale, TK_TimeLiteral, '/', TK_TimeLiteral}},
    {"`timescale 100ps / 100ps",
     {DR_timescale, TK_TimeLiteral, '/', TK_TimeLiteral}},
    {"`timescale 100 ps / 100 ps",  // space allowed only in `timescale context
     {DR_timescale, TK_DecNumber, TK_timescale_unit, '/', TK_DecNumber,
      TK_timescale_unit}},
    {"`celldefine", {DR_celldefine}},
    {"`celldefine\nmodule", {DR_celldefine, TK_module}},
    {"`endcelldefine", {DR_endcelldefine}},
    {"`resetall", {DR_resetall}},
    {"`unconnected_drive blah ", {DR_unconnected_drive, SymbolIdentifier}},
    {"`nounconnected_drive", {DR_nounconnected_drive}},
    {"`default_decay_time blah", {DR_default_decay_time, SymbolIdentifier}},
    {"`default_decay_time infinite", {DR_default_decay_time, TK_infinite}},
    {"`default_trireg_strength blah",
     {DR_default_trireg_strength, SymbolIdentifier}},
    {"`delay_mode_path       ", {DR_delay_mode_path}},
    {"`delay_mode_unit blah", {DR_delay_mode_unit, SymbolIdentifier}},
    {"`delay_mode_zero blahblah", {DR_delay_mode_zero, SymbolIdentifier}},
    {"`disable_portfaults blah", {DR_disable_portfaults, SymbolIdentifier}},
    {"`enable_portfaults blah", {DR_enable_portfaults, SymbolIdentifier}},
    {"`suppress_faults blah", {DR_suppress_faults, SymbolIdentifier}},
    {"`nosuppress_faults blah", {DR_nosuppress_faults, SymbolIdentifier}},
    {"`uselib lib=schmoozelib\n", {DR_uselib}},
    {"`protect", {DR_protect}},
    {"`endprotect", {DR_endprotect}},
    {"`begin_keywords random \"keywords\"",
     {DR_begin_keywords, SymbolIdentifier, TK_StringLiteral}},
    {"`end_keywords", {DR_end_keywords}},
    {"`default_nettype blah", {DR_default_nettype, SymbolIdentifier}},
};

static std::initializer_list<GenericTestDataSequence> kLexicalErrorTests = {
    // TODO(fangism): Return different error enums for different errors.
    {"111wire", {TK_OTHER}},
    {"wire 111wire;", {TK_wire, TK_OTHER, ';'}},
    {"`111macro\n", {TK_OTHER}},
    {"`111macrocall()\n", {TK_OTHER, '(', ')'}},
    {"` spacebad\n", {TK_OTHER, SymbolIdentifier}},
    {"\"\n", {TK_OTHER}},
    {"\"unterminated string literal", {TK_OTHER}},
    {"\"unterminated string literal\n", {TK_OTHER}},
    {"\"unterminated \\\nstring \\\nliteral\n", {TK_OTHER}},
    {"/*", {TK_OTHER}},
    {"/*\n", {TK_OTHER}},
    {"/* interminated comment", {TK_OTHER}},
    // Rejected ACSII characters
    {"\x7F", {TK_OTHER}},
    {"\x80", {TK_OTHER}},
    {"\xFF", {TK_OTHER}},
};

TEST(VerilogLexerTest, LexicalErrors) { TestFilteredLexer(kLexicalErrorTests); }
TEST(VerilogLexerTest, Comments) { TestLexer(kCommentTests); }
TEST(VerilogLexerTest, Attributes) { TestLexer(kAttributeTests, TK_ATTRIBUTE); }
TEST(VerilogLexerTest, AttributesSequence) {
  TestLexer(kAttributeSequenceTests);
}
TEST(VerilogLexerTest, MacroCalls) { TestLexer(kMacroCallTests); }
TEST(VerilogLexerTest, MacroCallsUnfiltered) {
  TestLexer(kUnfilteredMacroCallTests);
}
TEST(VerilogLexerTest, MacroDefines) { TestLexer(kMacroDefineTests); }
TEST(VerilogLexerTest, SymbolIdentifiers) {
  TestFilteredLexer(kSymbolIdentifierTests, SymbolIdentifier);
}
TEST(VerilogLexerTest, EscapedIdentifiers) {
  TestFilteredLexer(kEscapedIdentifierTests, EscapedIdentifier);
}
TEST(VerilogLexerTest, MacroIdentifiers) {
  TestLexer(kMacroIdentifierTests, MacroIdentifier);
}
TEST(VerilogLexerTest, Protected) { TestLexer(kProtectedTests); }
TEST(VerilogLexerTest, Keywords) { TestFilteredLexer(kKeywordTests); }
TEST(VerilogLexerTest, SingleCharToken) {
  TestLexer(kSingleCharTokenTests, verible::SingleChar);
}
TEST(VerilogLexerTest, RealTime) { TestLexer(kRealTimeTests, TK_RealTime); }
TEST(VerilogLexerTest, BasedNumbers) { TestLexer(kBasedNumberTests); }
TEST(VerilogLexerTest, TimeLiteral) {
  TestLexer(kTimeLiteralTests, TK_TimeLiteral);
}
TEST(VerilogLexerTest, Tricky) { TestLexer(kTrickyTests); }
TEST(VerilogLexerTest, Sequence) { TestFilteredLexer(kSequenceTests); }
TEST(VerilogLexerTest, StringLiteral) {
  TestLexer(kStringLiteralTests, TK_StringLiteral);
}
TEST(VerilogLexerTest, Edges) { TestFilteredLexer(kEdgeTests); }
TEST(VerilogLexerTest, UDP) { TestFilteredLexer(kUDPTests); }
TEST(VerilogLexerTest, UDPUnfiltered) { TestLexer(kUnfilteredUDPTests); }
TEST(VerilogLexerTest, ContextKeywords) {
  TestFilteredLexer(kContextKeywordTests);
}
TEST(VerilogLexerTest, BuiltinMethods) {
  TestFilteredLexer(kBuiltinMethodKeywordTests);
}
TEST(VerilogLexerTest, TimingChecks) { TestFilteredLexer(kTimingCheckTests); }
TEST(VerilogLexerTest, SystemTaskFunctionChecks) {
  TestFilteredLexer(kSystemTaskFunctionTests);
}
TEST(VerilogLexerTest, Preprocessor) { TestFilteredLexer(kPreprocessorTests); }
TEST(VerilogLexerTest, PreprocessorUnfiltered) {
  TestLexer(kUnfilteredPreprocessorTests);
}
TEST(VerilogLexerTest, Directives) { TestFilteredLexer(kDirectiveTests); }
TEST(VerilogLexerTest, DirectivesUnfiltered) {
  TestLexer(kUnfilteredDirectiveTests);
}

}  // namespace
}  // namespace verilog
